---
title:  "[JPA] QueryDsl - Qclass 사용 이유 알아보기"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - java
---

### QClass란
`QueryDSL`에서 `엔티티(Entity)`클래스의 `메타 정보`를 담고 있는 클래스다.  

QClass는 엔티티 클래스의 필드 구조를 그대로 복사하여 타입이 지정된 `Path 객체`로 표현한다.  
```
엔티티 클래스:  
@Entity
public class User {
    private String username;
    // ...
}

QClass (자동 생성):  
public class QUser extends EntityPathBase<User> {
    public final StringPath username = createString("username"); // <-- QClass 필드
    // ...
}
```
  
`QueryDSL` 코드를 작성할 때는 엔티티 필드의 이름인 `username`이라는 문자열을 직접 사용하는 것이 아니라 `QClass`가 제공하는 Path 타입이 있는 객체인 `QUser.user.username`을 사용한다.
```
// QueryDSL 코드 예시
queryFactory
    .selectFrom(QUser.user)
    .where(QUser.user.username.eq("홍길동")) // 필드 객체(username) 사용
    .fetch();
```
  
`QClass`를 사용하는 가장 큰 이유는 `타입 안정성` 보장이다.  
정적 타입 검사를 통해 쿼리 작성 시 발생하는 오류를 컴파일 단계에서 미리 잡을 수 있다.  

QClass를 사용해서 방지할 수 있는 문제들을 하나씩 알아보자.  

### 1. 필드명 오타 방지
예를 들어 일반적인 `SQL`이나 `JPQL`로 쿼리를 작성한다고 해보자.
```
JPQL/SQL (문자열 기반):
SELECT u FROM User u WHERE u.userame = '홍길동' -- 'username'의 오타
```
이 오타는 코드가 실행되어 데이터베이스로 쿼리가 전송될 때까지 발견되지 않아 `런타임 오류`를 유발한다.  

```
QueryDSL (QClass 기반):
// QUser.user.userame (X) -> 컴파일 에러 발생
QUser.user.username.eq("홍길동") // 올바른 필드에만 접근 가능
```
QClass는 엔티티의 필드에 해당하는 `타입이 있는 객체(Path 객체)`를 제공하기 때문에 IDE의 자동 완성 기능을 사용하게 되고 존재하지 않는 필드에 접근하려 하면 `컴파일 에러`가 발생한다.  
  
### 2. 잘못된 연산자 사용 방지
QClass는 각 엔티티 필드를 해당 타입에 맞는 Path 객체로 변환한다.  
* String 타입 필드는 StringPath  
* Integer 타입 필드는 NumberPath<Integer>  
  
이 덕분에 컴파일러는 해당 타입에 맞는 연산자만 사용할 수 있도록 강제한다.  
```
예시: 
문자열 필드인 username에만 사용할 수 있는 contains() 메서드를 숫자 필드인 age에 실수로 호출하려고 하면 컴파일 에러가 발생한다.
```
  
### 3. 리팩토링 안정성 확보
만약 엔티티 클래스에서 필드 이름을 username에서 userId로 변경한다고 생각해보자.   

1. 필드 이름을 `username`에서 `userId`로 변경  
2. 수정 후 QueryDSL을 빌드하면 `QUser` 클래스가 자동으로 업데이트  
3. 이때 `QUser` 클래스 내의 `public final StringPath username` 필드는 사라지고 `public final StringPath userId` 필드가 새로 생성  
4. 이전에 작성된 QueryDSL 코드에서 `QUser.user.username`을 사용하던 모든 라인은 이제 존재하지 않는 필드를 참조  
5. 컴파일 에러 발생  

`QClass`를 사용한 모든 `QueryDSL` 코드는 컴파일 에러를 뿜어내게 되므로 개발자는 에러가 난 부분만 수정하면 되어 리팩토링에 대한 안정성을 확보할 수 있다.  
`JPQL`처럼 문자열로 작성된 쿼리는 필드 이름을 변경해도 컴파일러가 잡아주지 못해 쿼리 코드를 일일이 찾아 수정해야 하는 불편함이 있다.  
  
> 결론 : QClass는 문자열 기반의 쿼리 작성 방식에서 발생할 수 있는 잠재적인 런타임 오류들을 모두 컴파일 단계로 끌어올려 개발자가 문제를 더 빠르고 안전하게 해결하도록 돕는 역할을 한다.



