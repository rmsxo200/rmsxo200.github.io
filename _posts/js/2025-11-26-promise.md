---
title:  "[JavaScript] 비동기 처리 Promise, async/await"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - js
---

특정 작업이 끝날 때까지 다른 작업을 멈추지 않고 계속 처리할 수 있게 해주는 방법이 바로 비동기 처리다.
이 비동기 처리를 방법중 하나인 Promise에 대해 알아보자.
  
### Promise란
`Promise`는 단어 그대로 약속이다.  
지금 당장은 아니지만 미래의 특정 시점에 결과를 돌려줄게라고 시스템에게 약속하는 객체이다.  
  
Promise는 다음 셋 중 하나의 상태를 가진다.  
> ⏳ Pending (대기): 이행하지도, 거부하지도 않은 초기 상태  
> ✅ Fulfilled (이행): 작업이 정상적으로 완료 (결과 값 획득)  
> ❌ Rejected (거부): 작업 실패 (오류 발생)  
  
<br/>
  
`Promise` 객체를 만들 때는 아래와 같이 `new Promise(...)`를 사용한다.
```
✨사용법✨

/* 선언 */
const 약속 = new Promise((resolve, reject) => {
    let 작업 = 작업_내용;

    if (작업 == 작업_성공) {
        resolve(결과값); // 성공했을 때, resolve 함수를 호출하고 결과를 전달
    } else {
        reject(에러객체); // 실패했을 때, reject 함수를 호출하고 실패 이유를 전달
    }
});
// resolve, reject의 변수명은 다르게 줘도 상관 없음

/* 사용 */
약속
  .then((결과) => {
    // resolve(결과값)이 호출되면 여기가 실행
    console.log('성공:', 결과);
  })
  .catch((에러) => {
    // reject(에러객체)가 호출되면 여기가 실행
    console.error('실패:', 에러);
  });
```

`Promise`의 가장 큰 특징은 `.then()` 메서드를 여러 개 연속해서 붙일 수 있다는 점이다. (`then() 체인`)  

```
약속
  .then((결과1) => { // 결과1의 값은 "1" 이라고 가정
    return 결과1 + 2; // 다음 then에게 결과를 넘겨줌
  })
  .then((결과2) => { // 결과2는 1 + 2의 결과인 "3"
    return 결과2 + 3; // // 다음 then에게 결과를 넘겨줌
  })
  .then((결과3) => { // 결과3은 3 + 2의 결과인 "5"
    console.log(결과3); // 최종 결과 출력 (5)
  })
  .catch((에러) => {
    console.error("에러 발생", 에러); // 체인 중 어느 하나라도 실패하면 catch에 잡힘
  });
```
각 .then()은 그 바로 앞의 .then()이 성공적으로 끝났을 때만 실행된다.  
모든 `.then()`은 실행된 후 `새로운 Promise`를 반환한다.  
덕분에 그 뒤에 또 다른 `.then()`을 붙일 수 있다.  
`.then()` 안에서 `return` 하는 값은 다음 `.then()`의 결과 매개변수로 전달되는 `새로운 Promise`가 된다.  
 
`.catch()`는 체인 중 어느 단계에서든 에러가 발생하면 그 자리에서 바로 실행된다.  
이것이 `.catch()`를 맨 마지막에 두는 이유다.  
  
> 🔅 `then() 체인`을 사용하면 콜백 지옥을 해결할 수 있다.
  
<br/>
  
### Promise 커피 주문 예제
```
const orderCoffee = (coffeeName) => {
    return new Promise((resolve, reject) => {
        // 3초 후에 커피가 완성된다고 가정 (비동기 작업)
        setTimeout(() => {
            const success = Math.random() > 0.3; // 70% 확률로 성공
            
            if (success) {
                // 성공하면 resolve 호출
                resolve(`✅ ${coffeeName} 완성`);
            } else {
                // 실패하면 reject 호출
                reject(`❌ ${coffeeName} 재료 소진`);
            }
        }, 3000);
    });
};

// 1. 함수 호출 (약속 생성)
orderCoffee('아이스 아메리카노')
    // 2. then: 약속이 '성공(Fulfilled)'했을 때 실행할 동작
    .then((result) => {
        console.log(result); // ✅ 아이스 아메리카노 완성
        return result + ' + 샷 추가';
    })
    // 3. then: 이전 then 약속이 '성공(Fulfilled)'했을 때 실행할 동작
    .then((result2) => {
        console.log(result2); // ✅ 아이스 아메리카노 완성 + 샷 추가
    })
    // 4. catch: 약속이 '실패(Rejected)'했을 때 실행할 동작
    .catch((error) => {
        console.error(error); // ❌ 아이스 아메리카노 재료 소진
    })
    // 5. finally: 성공/실패 여부와 상관없이 마지막에 항상 실행할 동작
    .finally(() => {
        console.log('--- 주문 처리 종료 ---');
    });

console.log('커피가 나오는 동안 다른 작업을 합니다...');  // << 이 로그가 '주문 처리 종료'보다 먼저 출력

==========================================
출력 결과 :
커피가 나오는 동안 다른 작업을 합니다...
✅ 아이스 아메리카노 완성
✅ 아이스 아메리카노 완성 + 샷 추가
--- 주문 처리 종료 ---
==========================================
```
<br/>  
 
이번엔 Promise를 더 간단히 쓸수있게 하는 async/await에 대해 알아보자.   
### async/await
async/await는 Promise를 더 쉽게 다루기 위해 만들어진 문법적인 기능이다.   
선언된 `Promise`를 사용할때 `async/await`를 사용하면 Promise의 `.then() 체인`을 사용하는 것보다 코드를 훨씬 더 직관적으로 만들 수 있다.
  
> * async :  
> 함수 앞에 붙여서 해당 함수가 비동기 함수이고 Promise를 반환할 거라고 선언한다.  

> * await :  
> Promise 앞에 붙여서 Promise가 결과를 내놓을 때까지 잠시 기다려줘라고 명령한다. > 기다리는 동안 JavaScript 엔진은 다른 작업을 처리한다.  
> async 함수 안에서만 await를 사용할 수 있습니다.  
  
`async` 함수는 항상 `Promise`를 반환한다.  
```
async function hello() {
  return "world";
}

// 위 코드는 아래 코드처럼 동작한다.

function hello() {
  return Promise.resolve("world");
}
```
  
`await`는 `Promise`가 끝날 때까지 기다렸다가 결과 값을 꺼내는 역할을 한다.
그리고 `await`는 `async`를 선언한 함수안에서만 사용할 수 있다.
```
async function hello() {
  const result = await fetch("/api");
  console.log("안녕"); // 다음 줄의 코드는 fetch() Promise가 완료된 후에 실행
}

// 위 코드는 아래처럼 동작한다.

function hello() {
  fetch("/api").then((response) => {
    // response는 await 코드의 result와 같은 응답 객체
    console.log("안녕"); // fetch() Promise가 완료된 후에 실행
  });
}
```
위 코드를 보면 비동기 코드이지만 `.then() 체인`을 쓰지 않고 동기 코드처럼 보여서 읽기 쉽다.  
  
<br/>  
  
### async/await 커피 주문 예제
위에서 `.then 체인`을 사용해 만든 예제를 `async/await`를 사용하는 방법으로 수정해보자.
```
// orderCoffee 함수는 동일
const orderCoffee = (coffeeName) => {
    return new Promise((resolve, reject) => {
        // 3초 후에 커피가 완성된다고 가정 (비동기 작업)
        setTimeout(() => {
            const success = Math.random() > 0.3; // 70% 확률로 성공
            
            if (success) {
                // 성공하면 resolve 호출
                resolve(`✅ ${coffeeName} 완성`);
            } else {
                // 실패하면 reject 호출
                reject(`❌ ${coffeeName} 재료 소진`);
            }
        }, 3000);
    });
};

async function processOrder() {
    try {
        // 1. 커피 주문 (Promise 생성)
        const result = await orderCoffee('아이스 아메리카노'); 
        console.log(result); // ✅ 아이스 아메리카노 완성

        // 2. 다음 작업 (이전 결과를 이용)
        const result2 = result + ' + 샷 추가';
        console.log(result2); // ✅ 아이스 아메리카노 완성 + 샷 추가
    } catch (error) {
        // 실패 시: reject() 실행 → 이 블록으로 이동
        console.error(error);
    } finally {
        // 성공/실패 여부와 상관없이 마지막에 항상 실행
        console.log('--- 주문 처리 종료 ---');
    }
}

// async 함수 호출
processOrder();
console.log('커피가 나오는 동안 다른 작업을 합니다...');  // << 이 로그가 '주문 처리 종료'보다 먼저 출력

==========================================
출력 결과 :
커피가 나오는 동안 다른 작업을 합니다...
✅ 아이스 아메리카노 완성
✅ 아이스 아메리카노 완성 + 샷 추가
--- 주문 처리 종료 ---
==========================================
```
<br/>
  
이번엔 `orderCoffee`함수는 그대로 두고 여러 커피를 순차 처리하는 예제를 만들어보자.
```
async function processOrder2() {
    try {
        console.log("1. 아메리카노 주문 시작");
        const result1 = await orderCoffee("아메리카노");
        console.log(result1);

        console.log("2. 카페라떼 주문 시작");
        const result2 = await orderCoffee("카페라떼");
        console.log(result2);

        console.log("3. 바닐라 라떼 주문 시작");
        const result3 = await orderCoffee("바닐라 라떼");
        console.log(result3);
    } catch (error) {
        console.error("주문 중 오류 발생:", error);
    } finally {
        console.log("--- 모든 커피 주문(순차) 종료 ---");
    }
}

processOrder2();
console.log('커피가 나오는 동안 다른 작업을 합니다...');

==========================================
출력 결과 :
1. 아메리카노 주문 시작
커피가 나오는 동안 다른 작업을 합니다...
✅ 아메리카노 완성
2. 카페라떼 주문 시작
✅ 카페라떼 완성
3. 바닐라 라떼 주문 시작
✅ 바닐라 라떼 완성
--- 모든 커피 주문(순차) 종료 ---
==========================================
```
`async`가 선언된 함수의 위부터 순차적으로 진행되는 것을 볼 수 있다.
`await`를 사용하는 부분중 하나라도 실패를 하게 된다면 이후 코드는 실행되지 않고 catch문을 타게된다.  
<br/>

### 병렬처리  
이번엔 병렬 처리하는 예제를 만들어보자.

### Promise.all()
> 모든 Promise가 성공(resolve) 하면 각 Promise의 결과값을 동일한 순서로 담은 `배열`을 반환한다.  
> 어떤 Promise 하나라도 reject되면 첫 번째로 실패한 Promise의 에러로 전체가 reject된다.  
> 웹 페이지 로딩에 필수적인 요소를 동시에 가져오는중 하나라도 실패하면 페이지를 보여주면 안될때 유용.
  
```
async function processOrdersParallel() {
    try {
        const promises = [
            orderCoffee("아메리카노"),
            orderCoffee("카페라떼"),
            orderCoffee("바닐라 라떼"),
        ];

        const results = await Promise.all(promises);
        console.log(results);

    } catch (error) {
        console.error("병렬 주문 중 하나라도 실패:", error);
    } finally {
        console.log("--- 모든 커피 주문(병렬) 종료 ---");
    }
}

processOrdersParallel();
console.log('커피가 나오는 동안 다른 작업을 합니다...');

==========================================
성공시 출력 결과 :
커피가 나오는 동안 다른 작업을 합니다...
(3) ['✅ 아메리카노 완성', '✅ 카페라떼 완성', '✅ 바닐라 라떼 완성']
0: "✅ 아메리카노 완성"
1: "✅ 카페라떼 완성"
2: "✅ 바닐라 라떼 완성"
length: 3[[Prototype]]: Array(0)
--- 모든 커피 주문(병렬) 종료 ---

실패시 출력 결과 :
커피가 나오는 동안 다른 작업을 합니다...
병렬 주문 중 하나라도 실패: ❌ 바닐라 라떼 재료 소진
--- 모든 커피 주문(병렬) 종료 ---
==========================================
```
`Promise.all()`는 성공한 프로미스 응답은 무시되어 성공한 결과값은 받을 수 없다.  
그래서 재요청시 이미 성공한 요청을 다시 보내는 문제가 발생한다.  
이런식으로 요청을 여러번 보내면 서버에 과부하를 줄 수도 있다.  
<br/>  
  
### Promise.allSettled()
> 성공/실패와 상관없이 모든 결과를 반환한다.  
> 절대 `reject`되지 않고 항상 `resolved` 된다.  
> 중간에 실패가 발생해도 멈추지 않는다.  
> 몇몇 API가 응답이 실패해도 성공한 API의 결과만이라도 사용자에게 보여줘야 할 때 유용.
  
```
async function processOrdersParallelAllSettled() {
    const promises = [
        orderCoffee("아메리카노"),
        orderCoffee("카페라떼"),
        orderCoffee("바닐라 라떼"),
    ];

    const results = await Promise.allSettled(promises);

    results.forEach((res, index) => {
        if (res.status === "fulfilled") {
            console.log(`{index + 1}.성공:`, res.value);
        } else {
            console.log(`${index + 1}.실패:`, res.reason);
        }
    });

    console.log("--- 병렬(allSettled) 주문 종료 ---");
}

processOrdersParallelAllSettled();
console.log('커피가 나오는 동안 다른 작업을 합니다...');

==========================================
출력 결과 :
커피가 나오는 동안 다른 작업을 합니다...
1,실패: ❌ 아메리카노 재료 소진
2,성공: ✅ 카페라떼 완성
3.실패: ❌ 바닐라 라떼 재료 소진
--- 병렬(allSettled) 주문 종료 ---
==========================================
```
`Promise.allSettled()`는 모든 작업이 완료될 때까지 무조건 기다린다.  
여러 개의 작업 중 하나가 명백하게 치명적인 오류를 일으키더라도 나머지 99개의 작업이 완료될 때까지 기다려야 하는 문제가 발생할 수 있다.  
이는 불필요한 지연 시간을 발생시킬 수 있다.
  
<br/>  
 
* 추가
  > Promise.race() : 경주처럼 가장 먼저 완료된 Promise의 결과로 결정  
  > 속도만 중요하고 결과가 성공이든 실패든 상관없이 가장 먼저 끝난 것을 채택
  >   
  > Promise.any() : 하나라도 성공하면 즉시 성공  
  > 가장 빠른 성공을 찾는 것을 목표로 하며 성공을 하나라도 찾을 때까지 실패는 무시  


| 메서드                 | 언제 resolve?                  | 언제 reject?                   | 리턴값                        |
| ---------------------- | ------------------------------- | ------------------------------ | ---------------------------- |
| **Promise.all**        | 모두 성공했을 때                | 하나라도 실패하면 즉시           | 성공 값 배열                 |
| **Promise.allSettled** | 모두 끝났을 때(성공/실패 무관)   | 없음(항상 resolve됨)            | `{ status, value/reason }[]`  |
| **Promise.race**       | 가장 먼저 결과를 받은 Promise가 성공이면 | 가장 먼저 결과를 받은 Promise가 실패면 | 하나의 value 또는 reason |
| **Promise.any**        | 가장 먼저 성공한 Promise가 있을 때 | 모두 실패했을 때              | 첫 성공 value                   |

