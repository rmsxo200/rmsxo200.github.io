---
title:  "[JavaScript] 비동기 처리 Promise"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - js
---

특정 작업이 끝날 때까지 다른 작업을 멈추지 않고 계속 처리할 수 있게 해주는 방법이 바로 비동기 처리다.
이 비동기 처리를 가능하게 하는 Promise에 대해 알아보자.
  
### Promise란
`Promise`는 단어 그대로 약속이다.  
지금 당장은 아니지만 미래의 특정 시점에 결과를 돌려줄게라고 시스템에게 약속하는 객체이다.  
  
Promise는 다음 셋 중 하나의 상태를 가진다.  
> ⏳ Pending (대기): 이행하지도, 거부하지도 않은 초기 상태  
> ✅ Fulfilled (이행): 작업이 정상적으로 완료 (결과 값 획득)  
> ❌ Rejected (거부): 작업 실패 (오류 발생)  
  
<br/>
  
`Promise` 객체를 만들 때는 아래와 같이 `new Promise(...)`를 사용한다.
```
✨사용법✨

/* 선언 */
const 약속 = new Promise((resolve, reject) => {
    let 작업 = 작업_내용;

    if (작업 == 작업_성공) {
        resolve(결과값); // 성공했을 때, resolve 함수를 호출하고 결과를 전달
    } else {
        reject(에러객체); // 실패했을 때, reject 함수를 호출하고 실패 이유를 전달
    }
});
// resolve, reject의 변수명은 다르게 줘도 상관 없음

/* 사용 */
약속
  .then((결과) => {
    // resolve(결과값)이 호출되면 여기가 실행
    console.log('성공:', 결과);
  })
  .catch((에러) => {
    // reject(에러객체)가 호출되면 여기가 실행
    console.error('실패:', 에러);
  });
```

`Promise`의 가장 큰 특징은 `.then()` 메서드를 여러 개 연속해서 붙일 수 있다는 점이다. (`then() 체인`)  

```
약속
  .then((결과1) => { // 결과1의 값은 "1" 이라고 가정
    return 결과1 + 2; // 다음 then에게 결과를 넘겨줌
  })
  .then((결과2) => { // 결과2는 1 + 2의 결과인 "3"
    return 결과2 + 3; // // 다음 then에게 결과를 넘겨줌
  })
  .then((결과3) => { // 결과3은 3 + 2의 결과인 "5"
    console.log(결과3); // 최종 결과 출력 (5)
  })
  .catch((에러) => {
    console.error("에러 발생", 에러); // 체인 중 어느 하나라도 실패하면 catch에 잡힘
  });
```
각 .then()은 그 바로 앞의 .then()이 성공적으로 끝났을 때만 실행된다.  
모든 `.then()`은 실행된 후 `새로운 Promise`를 반환한다.  
덕분에 그 뒤에 또 다른 `.then()`을 붙일 수 있다.  
`.then()` 안에서 `return` 하는 값은 다음 `.then()`의 결과 매개변수로 전달되는 `새로운 Promise`가 된다.  
 
`.catch()`는 체인 중 어느 단계에서든 에러가 발생하면 그 자리에서 바로 실행된다.  
이것이 `.catch()`를 맨 마지막에 두는 이유다.  
  
> 🔅 `then() 체인`을 사용하면 콜백 지옥을 해결할 수 있다.
  
<br/>
  
### Promise 커피 주문 예제
```
const orderCoffee = (coffeeName) => {
    return new Promise((resolve, reject) => {
        // 3초 후에 커피가 완성된다고 가정 (비동기 작업)
        setTimeout(() => {
            const success = Math.random() > 0.3; // 70% 확률로 성공
            
            if (success) {
                // 성공하면 resolve 호출
                resolve(`✅ ${coffeeName} 완성`);
            } else {
                // 실패하면 reject 호출
                reject(`❌ ${coffeeName} 재료 소진`);
            }
        }, 3000);
    });
};

// 1. 함수 호출 (약속 생성)
orderCoffee('아이스 아메리카노')
    // 2. then: 약속이 '성공(Fulfilled)'했을 때 실행할 동작
    .then((result) => {
        console.log(result); // ✅ 아이스 아메리카노 완성
        return result + ' + 샷 추가';
    })
    // 3. then: 이전 then 약속이 '성공(Fulfilled)'했을 때 실행할 동작
    .then((result2) => {
        console.log(result2); // ✅ 아이스 아메리카노 완성 + 샷 추가
    })
    // 4. catch: 약속이 '실패(Rejected)'했을 때 실행할 동작
    .catch((error) => {
        console.error(error); // ❌ 아이스 아메리카노 재료 소진
    })
    // 5. finally: 성공/실패 여부와 상관없이 마지막에 항상 실행할 동작
    .finally(() => {
        console.log('--- 주문 처리 종료 ---');
    });

console.log('커피가 나오는 동안 다른 작업을 합니다...');  // << 이 로그가 '주문 처리 종료'보다 먼저 출력

==========================================
출력 결과 :
커피가 나오는 동안 다른 작업을 합니다...
✅ 아이스 아메리카노 완성
--- 주문 처리 종료 ---
==========================================
```
