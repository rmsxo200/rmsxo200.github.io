---
title:  "[JavaScript] 객체 리터럴 내부 함수 정의"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - js
---

### 객체 리터럴
객체 리터럴이란 클래스를 만들거나 `new Object()`를 쓰지 않고 변수에 중괄호`{}`로 직접 객체 형태를 적어서 만드는 방식이다.   
  
> 객체(object) : 데이터와 함수가 하나로 묶여있고 키-값의 쌍으로 이루어진 데이터 구조  
> 리터럴(literal) : 값을 코드에 직접 적는 방식  
  
```
let count = 5;         // 숫자 리터럴
let message = "OK";    // 문자열 리터럴
let isActive = true;   // 불리언 리터럴
let numArray = [1, 2, 3];   // 불리언 리터럴
let obj = { x: 10, y: 20 }; // { x: 10, y: 20 }은 객체 리터럴
```
  
객체 리터럴에서 함수를 정의하여 사용하는 방법을 알아보려고 한다.  

JavaScript에서 함수를 관리하는 방식은 다양하다.  
그중에서도 객체 리터럴에 함수를 그룹화하여 선언하는 방식은 모듈화, 네임스페이스 관리, 가독성 향상에 큰 도움이 되는 패턴이다.  
   
1. 네임스페이스 충돌 방지  
    * 전역 범위에 함수를 무분별하게 선언하면 이름 충돌이 생길 수 있다.  
    * 객체 안에 함수를 담으면 `userService.getUser()` 같은 형태로 안전하게 사용 가능해진다.  

2. 기능 단위의 모듈화
    * 사용자 관련, 상품 관련 등 기능별로 묶어서 관리하면 유지보수가 훨씬 쉬워진다.  

3. 의미가 더 잘 드러남
    * `calculate()`보다는 `math.calculate()`가 어떤 역할을 하는 함수인지 더 명확하다.  
    * 어떤 이벤트를 처리하는 함수 모음이라는 명확한 역할을 정의한다.  
  
4. 쉬운 전달 및 재사용
   * 객체로 묶으면 관련 함수들을 하나의 단위로 다른 모듈이나 컴포넌트에 쉽게 전달하거나 재사용할 수 있다.
   
개별 함수로 선언하는 방식은 간단한 스크립트에는 편리할 수 있지만 애플리케이션의 규모가 커질수록 이름 충돌과 관리의 어려움이 생긴다.  
객체 리터럴로 그룹화하는 방식은 이러한 문제를 해결하고 코드를 응집력 있고 안전하며 확장성 있게 만들어준다.  
  
### 1. 메서드 축약
`getUser(id) { ... }`  
ES6에서 도입된 가장 간결한 문법이다.  
객체의 메서드를 정의할 때 가장 권장되는 방식  
- ES6 이후 버전 사용가능
- this 바인딩이 일반 함수처럼 동작
- 함수 내부에서 this 키워드를 사용하면 호출 시점의 객체(calculator)*를 가리킴
- 생성자 함수로 사용 불가 (new 사용 시 오류)
```
const calculator = {
    msg : '계산 완료',
    plus(num1, num2) {
        console.log(`${this.msg} : ${num1 + num2}`);
    },
    minus(num1, num2) {
        console.log(`${this.msg} : ${num1 - num2}`);
    },
};

calculator.plus(1,2); // 계산 완료 : 3
let obj = new calculator.minus(2, 1); // ❌ Uncaught TypeError: calculator.minus is not a constructor
```

### 2. 함수 표현식
`getUser: function(id) { ... }`  
표준적이고 전통적인 메서드 정의 방식 (ES5 스타일)  
- ES6 이전 버전도 사용 가능
- this 바인딩이 일반 함수처럼 동작
- 함수 내부에서 this 키워드를 사용하면 호출 시점의 객체(calculator)를 가리킴
- 생성자 함수로 사용 가능
```
const calculator = {
    msg : '계산 완료',
    plus : function(num1, num2) {
        console.log(`${this.msg} : ${num1 + num2}`);
    },
    minus : function(num1, num2) {
        console.log(`${this.msg} : ${num1 - num2}`);
    },
};

calculator.plus(1,2); // 계산 완료 : 3
let obj = new calculator.minus(2, 1); // undefined : 1
```
  
### 3. 화살표 함수
`getUser: (id) => { ... }`  
ES6에서 도입되었으며 this 바인딩 측면에서 다른 두 방식과 완전히 다르다.  
   - ES6 이후 버전 사용가능  
   - 함수가 선언된 상위 스코프의 this를 그대로 가져옴, 렉시컬 this (Lexical this)  
   - 생성자 함수로 사용 불가 (new 사용 시 오류)  
```
const calculator = {
    msg : '계산 완료',
    plus : (num1, num2) => {
        console.log(`${this.msg} : ${num1 + num2}`);
    },
    minus : (num1, num2)  => {
        console.log(`${this.msg} : ${num1 - num2}`);
    },
};

calculator.plus(1,2); // undefined : 3
let obj = new calculator.minus(2, 1); // ❌ Uncaught TypeError: calculator.minus is not a constructor
```

각 방식은 this 사용과 new 키워드를 사용하는데 있어 큰 차이가 있다.  
근데 new로 인스턴스를 생성하려면 class를 사용하는 것이 훨씬 좋다.   
  
-----
  
|방식            |this                                                      |생성자                      |버전                 |
|---------------|-----------------------------------------------------------|---------------------------|---------------------|
|**메서드 축약**|this 바인딩이 일반 함수처럼 동작 (동적 바인딩)                 |사용 불가 (new 사용 시 오류)|ES6 이후 버전 사용가능 |
|**함수 표현식**|this 바인딩이 일반 함수처럼 동작 (동적 바인딩)                 |사용 가능                  |ES6 이전도 버전 사용가능|
|**화살표 함수**|함수가 선언된 상위 스코프의 this를 그대로 가져옴 (렉시컬 바인딩)|사용 불가 (new 사용 시 오류)|ES6 이후 버전 사용가능 |

