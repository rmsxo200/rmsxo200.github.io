---
title:  "[JavaScript] 함수 선언 방식"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - js
---
### 함수 선언 방법들
```
// 1. 함수 선언문
function fn1() {
  return "fn1";
}

// 2. 함수 표현식
const fn2 = function() {
  return "fn2";
};

// 3. 객체 메서드 정의
const obj = {
  fn3() {
    return "fn3";
  }
};

// 4. 화살표 함수
const fn4 = () => "f4";

// 5. 클래스 메서드
class MyClass {
  fn5() {
    return "f5";
  }
}
```
<br/>  
  
### 1. 함수 선언문 (Function Declaration)  
> 사용하면 좋은 상황 : 전역 유틸 함수, 재귀 함수, 라이프사이클 상 먼저 필요한 함수   
> * 공통 유틸 함수 (예: 날짜 포맷)  
> * 재귀 호출이 필요한 함수  
> * 파일 상단 혹은 어디서든 먼저 호출될 가능성이 있는 함수  
>  
> <br/>  
>   
> 이유 :  
> * 함수 전체가 호이스팅(Function Hoisting)**되므로, 선언 위치와 관계없이 사용 가능하여 코드 구성이 자유롭다  
> * 이름이 명확해 재귀 호출에 자연스럽다  
  
```
// 예시
// 코드 어느 위치에서든 함수를 호출 가능
console.log(formatDate(new Date())); // '2025-12-05' 

function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}
```
<br/>  
  
### 2. 함수 표현식 (Function Expression)  
> 사용하면 좋은 상황 : 조건부 함수, 콜백, 클로저 생성
> * 특정 상황에서만 함수를 생성하거나 실행해야 할 때 (예: if 문 내부)  
> * 함수 자체가 변수처럼 동작해야 할 때 (다른 함수에 인자로 전달, 반환 값으로 사용)  
> * 클로저를 통해 데이터를 숨기거나 특정 상태를 보존하고 싶을 때    
>  
> <br/>  
>   
> 이유 :  
> * 변수에 할당되므로 변수처럼 다룰 수 있고, 변수의 스코프 규칙을 따른다  
> * TDZ 때문에 초기화 전 호출이 불가능하여 함수 호출 시점을 명확히 통제할 수 있다
  
```
// 예시
// 클로저를 활용하여 카운터 상태를 보호하는 함수
function createCounter() {
  let count = 0; // 외부에서 직접 접근 불가한 상태 (숨겨진 데이터)

  // 함수 표현식을 반환하여 내부 함수가 클로저를 형성함
  return function() { // 이 내부 함수가 'count' 변수를 기억하고 접근함
    count += 1;
    return count;
  };
}

const counterA = createCounter(); // 반환된 함수 표현식이 counterA에 할당됨
console.log(counterA()); // count 상태를 보존하며 조작
```
<br/>   

### 3. 객체 메서드 정의 (Object Method Definition)  
> 사용하면 좋은 상황 : 객체가 행동을 갖는 경우
> * 객체 내부의 속성(상태)과 행동(메서드)을 묶고 싶을 때 (캡슐화)  
> * 단순한 서비스 객체, 유틸 객체 등 객체 지향 패턴이 필요 없는 기능적 객체    
>  
> <br/>  
>   
> 이유 :  
> * 객체가 "상태 + 메서드"를 함께 가지는 구조가 매우 직관적이다   
> * this가 해당 객체를 자연스럽게 가리키므로 내부 상태에 쉽게 접근할 수 있다
  
```
// 예시
const userService = {
  // 객체의 상태 (데이터)
  currentUser: { id: 1, name: 'Alice' },

  // 단축 구문을 사용한 객체 메서드 정의
  getUserName() {
    // this는 userService 객체를 가리킵니다.
    return this.currentUser.name;
  },

  updateName(newName) {
    this.currentUser.name = newName;
    console.log(`이름 업데이트 완료: ${this.currentUser.name}`);
  }
};

console.log(userService.getUserName()); // 출력: "Alice"
userService.updateName('Bob');          // 출력: "이름 업데이트 완료: Bob"
```
<br/>   
  
### 4. 화살표 함수 (Arrow Function)  
> 사용하면 좋은 상황 : 콜백, this 유지가 필요한 곳, 짧은 함수  
> * 이벤트/비동기 콜백에서 this가 상위 스코프를 유지해야 할 때  
> * map, filter, reduce 같은 배열 반복 시 간단한 함수 전달  
> * 간결한 1회용 함수 또는 표현식만으로 반환 가능한 경우 (암묵적 반환)  
>  
> <br/>  
>   
> 이유 :  
> * 자신만의 this를 가지지 않으며 상위 스코프의 this를 그대로 바인딩(Lexical this) 함  
> * 코드가 매우 짧고 간결하며 자동으로 반환(Implicit Return)이 가능하다
  
```
// 예시
// 1. 짧은 콜백 함수 (Implicit Return)
const numbers = [1, 2, 3, 4];
const squared = numbers.map(num => num * num); // return 키워드 생략 가능
console.log(squared); // 출력: [1, 4, 9, 16]

// 2. this 바인딩 유지 (Lexical this)
class DataFetcher {
  constructor() {
    this.url = '/api/data';
  }

  fetchData() {
    // ❌ 일반 함수를 사용하면 setTimeout 내부의 this는 전역 객체(window/undefined)가 됩니다.
    // ⭕ 화살표 함수를 사용하면 this는 상위 스코프인 DataFetcher 인스턴스를 유지합니다.
    setTimeout(() => {
      console.log(`데이터를 가져오는 중: ${this.url}`);
    }, 100);
  }
}

new DataFetcher().fetchData(); // 출력: "데이터를 가져오는 중: /api/data" 
```
<br/>  
 
### 5. 클래스 메서드  
> 사용하면 좋은 상황 : 객체 지향 구조가 필요한 경우   
> * 여러 인스턴스를 생성해야 할 때  
> * 확장성과 유지보수가 중요하며 상속 관계가 필요한 경우  
> * 서비스/도메인 모델/컴포넌트 등 OOP(객체 지향 프로그래밍) 설계  
>  
> <br/>  
>   
> 이유 :  
> * 메서드가 Prototype에 저장되어 메모리 효율적이다  
> * 상속/확장이 가능하여 도메인 모델 설계에 매우 적합하다
  
```
// 예시
class Component {
  render() {
    console.log('기본 컴포넌트 렌더링');
  }
}

class Button extends Component {
  // 오버라이딩
  render() {
    // super.render()를 사용하여 부모의 기능을 호출할 수도 있습니다.
    super.render(); 
    console.log('버튼 스타일 추가 렌더링');
  }
}

const myButton = new Button();
myButton.render();

// 출력: 
// 기본 컴포넌트 렌더링
// 버튼 스타일 추가 렌더링
```
<br/>    
  
### 호이스팅
| 방식            | 호이스팅     | 선언 전 호출 가능 여부 | 비고                |
| ------------- | ------------ | ----------- | ---------------------- |
| **함수 선언문**    | ⭕        | ⭕        | 함수 전체가 호이스팅됨           |
| **함수 표현식**    | ❌ (변수만 호이스팅)   | ❌         | 변수는 올라가지만 값은 undefined |
| **객체 메서드 정의** | ❌          | ❌         | 객체 변수(const/let)의 스코프 규칙을 따름 (TDZ), 객체 자체가 호이스팅되지 않기 때문에 메서드도 못씀    |
| **화살표 함수**    | ❌ (변수만 호이스팅)   | ❌         | 함수 표현식과 동일             |
| **클래스 메서드**   | ❌ (클래스 선언 정보만 호이스팅됨) | ❌         | TDZ 때문에 선언 전 사용 불가 (ReferenceError)     |
   
> 초기화 시점  
> * var : 선언과 동시에 undefined로 자동 초기화됨, 선언 전에 접근 가능 (값은 undefined)  
> * let, const, class : 실제 선언문이 있는 라인에 도달했을 때 초기화됨, TDZ에 의해 선언 전에 접근 불가능 (ReferenceError 발생)  

