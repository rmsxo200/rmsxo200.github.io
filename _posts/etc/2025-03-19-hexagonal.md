---
title:  "헥사고날 아키텍처(Hexagonal architecture)와 멀티모듈"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - etc
---
헥사고날 아키텍처와 멀티모듈을 이용하여 프로젝트를 설게하려고한다.  
각각의 기술에 대해 알아보자.  
<br/>  
<br/>  
  
![헥사고날 아키텍처 구조](/imgs/hexagonal/hexagonal-architecture.png)  
<span style="font-size:90%;color:gray;">[이미지출처 : https://tech.kakaobank.com/posts/2311-hexagonal-architecture-in-messaging-hub/]</span>  
  
헥사고날 아키텍처란 `Adapter`, `Port`, `domain`으로 구성된 계층형 아키텍처다.  
> 위 이미지에서 `Use Case`는 도메인 서비스로직, `Entity`는 도메인 모델에 해당한다.  
> `Ports and Adapter` 아키텍처 라고도 한다.  
  
<br/>  
  
### 🌳 각 계층별 특징  
**🍋 어댑터 계층(Adapter)**
  - 어댑터 계층은 외부와 소통하는 계층이다.  
  - 외부에 요청을 받는 `입력 어댑터(Input Adapter)`와 외부시스템에 접근하는 `출력 어댑터(Output Adapter)`가 나뉘어 있다.  
    - `Input Adapter` : 외부에 요청을 받는 어뎁터 (컨트롤러 메시지 큐 리스너 등)  
    - `Output Adapter` : 외부 시스템과 상호작용 (DB, 외부API 등)  
    
**🍋 포트 계층(Port)**  
  - `어댑터 계층`과 `도메인 계층` 사이 `중간 인터페이스` 역할을 수행하는 계층이다.  
  - 포트 계층이 도메인 계층에 접근하기에 도메인 로직이 외부 환경과 완전히 분리되어 외부 시스템이 변경되어도 도메인 로직에 영향이 가지 않는다.  
  - `입력 포트(Input Port)`와 `출력 포트(Output Port)`로 나뉘진다.  
    - `Input Port` : 외부요청에 대한 처리를 하는 비즈니스 로직이다.  
    - `Output Port` : 출력포트는 내부에서 외부 시스템을 호출할 때 사용한다.  
  
**🍋 도메인 계층(Domain)**  
  - `핵심 비즈니스 로직`을 처리하는 계층이다.
  - 외부 의존성이 배제되어 외부 환경과 `독립적`으로 동작한다.  
   
> 헥사고날 아키텍처의 각 계층은 위와 같은 특징이 있다.  
  
<br/>  
  
### 🌳 헥사고날 아키텍처를 사용하는 이유  
> 헥사고날 아키텍처를 사용하면 `저수준(infra 등)`의 변경사항이 `고수준(domain)`에 영향을 주지 않게 된다.   
> `포트 계층`에서 비즈니스 로직이 수행되지 않고 `도메인 계층`을 호출하여 비즈니스 로직을 처리하기 떄문에 외부 시스템과 완전히 독립되게 된다.  
> 그로 인해 외부 `시스템의 변경`이 있을 경우 비즈니스 로직은 영향을 받지 않고 `어댑터 계층`만 교체하면 된다.  
> 이처럼 도메인 로직을 보호하고 기술 교체가 유연해진다.  
> 
> 하지만 도메인의 `순수성`을 유지하려고 노력하면 역으로 `생산성`은 떨어지게 된다.  
> 예를 들어 JPA를 사용하는 경우 를 가정하자.  
> `도메인 계층`은 독립적이기에 `도메인 모델`과 `JPA 엔티티`를 분리하여 사용하게 된다.  
> 그렇다면 `포트 계층`에서 `도메인 계층`을 호출할 떄 `JPA 엔티티`는 `도메인 모델`로 변환되는 과정을 거쳐야 한다.  
> 그로인해 매핑하는 과정등이 존재해 로직이 복잡해 진다.  
> 또한 JPA의 변경 감지를 사용하지 못하게 된다.  
> 
> 그렇기에 도메인계층의 순수성을 너무 고집하지 않고 상황에 따라 도메인 모델과 JPA 엔티티를 분리하지 않고 사용하는 것도 방법이다.  
  
<br/>  
  
### 🌳 멀티모듈이란
> `java`에서 `모듈`은 외부에서 재사용 할 수 있는 패키지들의 묶음이다.  
> 하나의 루트 프로젝트 안에 여러개의 하위 `모듈`이 구성된 구조를 `멀티모듈`이라고 한다.  
> 각 모듈은 독립적인 기능을 담당하며 필요에 따라 서로 의존할 수도 있다.  
> 또한 각 모듈별로 `빌드` 및 `배포`가 가능하다.  
  
<br/>  
  
### 🌳 멀티모듈 구성 방법  
1. 도메인 단위로 구분  
   - `마이크로서비스` 형태로 구성되는 경우 주로 사용되며 각각 모듈은 별도의 `Application`을 구성  
   - 예) `member`, `movie`, `admin`, `payment`, `common` 등 각 도메인 별로 분리  
  
2. 계층 형식으로 구분  
   - 예) `controller`, `service`, `repository` 등 각 계층별로 분리  
  
<br/>  
   
### 🌳 멀티모듈을 사용하는 이유  
멀티모듈을 사용했을 때 아래와 같은 장점이 있다.  
  
1. `재사용성` :  
     - `단일모듈`에서는 여러 프로젝트에 동일한 코드가 중복될 수 있지만 공통 모듈을 분리함으로써 코드의 중복을 줄이고 `재사용성`을 높일 수 있다.
2. `의존성 관리` :   
     - 루트 프로젝트에서 공통 의존성 및 설정을 한 번에 관리 가능하다.  
     - 모듈 간 `의존성`을 설정하여 아키텍처 규칙을 강제할 수 있다.  
3. `빌드 최적화` : 
     - 변경된 모듈만 빌드하여 전체 빌드 시간을 단축시킬 수 있다.  
4. `협업` : 
      - 각 모듈별로 개발범위를 나눌 수 있어 팀원간 역할 분담이 명확해 진다.  
5. `독립적 배포`
    -  각 모듈을 `독립적`으로 배포 가능하다.  
    -  특히 `마이크로서비스 아키텍처(MSA)`에서는 각 모듈이 개별 서비스 단위로 배포가 가능하다.  
6. `개발환경 통합` : 
    - 여러 개의 프로젝트를 멀티모듈 구조로 통합하면 하나의 IDE에 열어 모든 모듈을 함께 개발할 수 있다.  
    - 하나의 실행 인스턴스로 전체 애플리케이션을 구동할 수 있어 실행 환경을 단순화하고 개발 및 테스트 효율을 높일 수 있다.  
  
위의 장점들을 통해 볼 때 멀티모듈은 복잡한 프로젝트를 구조적으로 나누어 개발 및 유지보수를 더욱 쉽게 할 수 있게끔 한다.  
또한 시스템 확장에 유리히며 비즈니스 로직이 복잡한 시스템일 경우 더 큰 효과를 발휘한다.  
  
하지만 주의해야할 점도 있다.  
위에서 공통의 모듈을 만들어 코드의 중복을 줄인다고 했는데 `common` 모듈을 사용할 경우 해당 모듈의 크기가 너무 커지고 관리가 안되는 통제불능 상태가 될 수 있다.  
그렇게에 공통 모듈을 지양하는 쪽으로 설계하는것 같다.  
> 통제불능의 공통 모듈보다 차라리 중복 코드를 작성하는게 더 낫다는 의견이 있음    
  
<br/>  
  
### 🌳 프로젝트 설계
그럼 위에 헥사고날 아키텍처와 멀티모듈을 이용하여 프로젝트를 설계해보자.     
아키텍처의 각 계층별로 모듈을 구성할 것이다.  
  
<br/>  
  
### 🌳 프로젝트 구조
```
  root-project
  │
  ├── module-domain                                 // 도메인 계층
  │   │                                             // 핵심 비즈니스 로직과 규칙을 정의하며 외부 시스템에 의존하지 않음
  │   ├── src/main/java/com/example/domain
  │   │   ├── Order.java                            // 도메인 모델
  │   │   └── service
  │   │       └── OrderDomainService.java           // 도메인 서비스
  │   └── build.gradle.kts
  │
  ├── module-application                            // 애플리케이션 계층
  │   │                                             // 입력/출력 포트를 정의하고 애플리케이션 서비스(비즈니스 흐름)를 구현함
  │   ├── src/main/java/com/example/application
  │   │   ├── port
  │   │   │   ├── in
  │   │   │   │   └── OrderService.java             // 입력 포트 (인터페이스)
  │   │   │   └── out
  │   │   │       └── OrderRepositoryPort.java      // 출력 포트 (인터페이스)
  │   │   └── service
  │   │       └── OrderServiceImpl.java             // 애플리케이션 서비스 (입력 포트 구현체)
  │   └── build.gradle.kts
  │
  ├── module-infrastructure                         // 인프라 계층
  │   │                                             // 애플리케이션 계층의 출력 포트를 구현하며 DB, 외부 API 등 외부 시스템과 상호작용
  │   ├── src/main/java/com/example/infrastructure
  │   │   ├── adapter
  │   │   │   └── OrderRepositoryAdapter.java       // 출력 포트 구현체 (DB 접근)
  │   │   ├── entity
  │   │   │   └── OrderEntity.java                  // JPA 엔티티 (ORM 매핑), 필요에 따라 해당 경로 없애고 도메인 모델과 통합
  │   │   └── repository
  │   │       └── SpringDataOrderRepository.java    // Spring Data JPA 리포지토리
  │   └── build.gradle.kts
  │
  └── module-adapter                                // 어댑터 계층
      │                                             // 외부 요청(웹, 메시지, CLI 등)을 수신하는 진입점으로 입력 포트를 호출
      ├── src/main/java/com/example/adapter
      │   ├── web
      │   │   └── OrderController.java               // 웹 어댑터 (REST 컨트롤러)
      ├── SpringBootApplication                      // Spring Boot 실행
      └── build.gradle.kts
```
  
* 애플리케이션 계층에 출력 포트 구현체가 없는 이유
    * 애플리케이션 계층에는 출력 포트의 인터페이스만 정의되고 출력 포트의 구현체는 인프라스트럭처 계층에 존재합니다.  
    * 출력 포트는 외부 기술(예: DB, 메시징 시스템)에 대한 추상화로 애플리케이션 서비스가 이를 호출하여 외부 시스템과의 의존성을 최소화할 수 있도록 한다. 
    * 이를 통해 애플리케이션 서비스는 외부 시스템의 구체적인 구현을 알 필요 없이 출력 포트 인터페이스만을 호출하여 동작한다.  
  
<br/>  
  
### 🌳 데이터 흐름
```
컨트롤러(Input Adapter)  →  입력포트(Input Port)  →  출력포트(Output Port)  →  DB접근(Output Adapter)  
                                   ↓                      ↳ 출력포트의 구현체는 
                         Domain Servier(Domain model)         Output Adapter계층에 구현 
```
  
